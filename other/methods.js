const numArr = [2, 32, 1234, 54, 323];

let value;

value = numArr.length;


value = Array.isArray(numArr); //true
value = numArr[2]; //1234
numArr[2] = 12; //[2, 32, 12, 54, 323]
value = numArr.indexOf(32); // 1

value = numArr.push(100); //добавление в конец массива .. 6 (6) [2, 32, 12, 54, 323, 100]
value = numArr.pop(); //метод удаляет последнее значение массива
value = numArr.unshift(111); // метод добавляет в начало массива значение
value = numArr.shift(); // метод добавляет в начало массива значение
value = numArr.slice(0, 2); //возвращет ту часть которую вырезал .. (2) [2, 32] (5) [2, 32, 12, 54, 323]
// value = numArr.splice(1, 1) // [32] (4) [2, 12, 54, 323]
// value = numArr.splice(1, 2) // (2) [32, 12] (3) [2, 54, 323]
// value = numArr.splice(1, 2, 'one', 'two') // (2) [32, 12] (5) [2, 'one', 'two', 54, 323] //добавили 2 эллемента в массив, 2 вбрали.
value = numArr.splice(1, 0, 'one', 'two') // дл того чтобы просто что-то дабавить сначала надо поставить 0, все что после него будет добавленно в массив .. делает копию массива но в него ничего не передать
value = numArr.reverse();
// value = numArr.concat(numArr) // похволяет конкатенировать несколько массивов, но в данном случае я продублировал еще раз все значения массива .. копирует текущий массив и добавляет то что нужно добавить и возвращает
value = numArr.concat(1, 2, 3) // мы модем сюда передавать как массивы так и просто значения как в это случае, которые добавленны в конец массива .. (10) [323, 54, 12, 32, 'two', 'one', 2, 1, 2, 3]

value = [].concat(1, 2, 3) // можно вызвать данные метод на пустом массиве (3) [1, 2, 3] (7) [323, 54, 12, 32, 'two', 'one', 2]
value = numArr.join() // метод делает из массива строку и возвращает ее. При исользовании "" вернет строку без запятых
value = numArr.join(" ") // метод делает из массива строку и возвращает ее. При исользовании " " поставит пробелы между значениями массива
value = "hello world".split() // метод делает из строки массив .. ['hello world'] 
value = "hello world".split("") // метод делает из строки массив, и разобьет по буквам при такой записи .. (11) ['h', 'e', 'l', 'l', 'o', ' ', 'w', 'o', 'r', 'l', 'd']
value = "hello world".split(" ") // метод делает из строки массив, разбивает в данном случае не по буквам , а по эллементам массива .. (2) ['hello', 'world'] 




console.log(value, numArr);


// let arr = [1, 2, 3, 4, 5]

// arr.push(1) // 1
// arr.pop() // [1, 2, 3, 4]
//arr.shift() // [2, 3, 4, 5]
//arr.unshift(1) // [1, 1, 2, 3, 4, 5]
//delete arr[1] // [1, empty, 3, 4, 5]
// arr.splice(1, 1) // [1, 3, 4, 5]
// arr.splice(0, 1, 11) // [11, 2, 3, 4, 5]
// arr.splice(-1, 0, 6) // [1, 2, 3, 4, 6, 5]
// let brrr = arr.splice(0, 3) // arr = [4, 5] brrr = [1, 2, 3]
// arr.splice() // [1, 2, 3, 4, 5]
// arr.slice() // [1, 2, 3, 4, 5]
// console.log(arr.concat([6, 7], [8, 9])) //[1, 2, 3, 4, 5, 6, 7, 8, 9]
// arr = arr.concat([6, 7], [8, 9]) //[1, 2, 3, 4, 5, 6, 7, 8, 9]

// let arrayLike = {
//   0: "что-то",
//   length: 1
// };
// arr = arr.concat(arrayLike) // [1, 2, 3, 4, 5, {…}]

// let arrayLike = {
//   0: "что-то",
//   1: "ещё",
//   [Symbol.isConcatSpreadable]: true, // если объект имеет специальное свойство Symbol.isConcatSpreadable, то он обрабатывается concat как массив
//   length: 2
// };
// arr = arr.concat(arrayLike) // [1, 2, 3, 4, 5, 'что-то', 'ещё']
// arr.forEach(alert); // Метод arr.forEach позволяет запускать функцию для каждого элемента массива.
/*
Методы arr.indexOf, arr.lastIndexOf и arr.includes имеют одинаковый синтаксис и делают по сути то же самое, что и их строковые аналоги, но работают с элементами вместо символов:

arr.indexOf(item, from) ищет item, начиная с индекса from, и возвращает индекс, на котором был найден искомый элемент, в противном случае -1.
arr.lastIndexOf(item, from) – то же самое, но ищет справа налево.
arr.includes(item, from) – ищет item, начиная с индекса from, и возвращает true, если поиск успешен.
*/

// let arr = [1, 0, false];
// arr = arr.indexOf(0); // 1
// arr = arr.indexOf(false); // 2
// arr = arr.indexOf(null); // -1

// alert( arr.includes(1) ); // true
/*Обратите внимание, что методы используют строгое сравнение ===. Таким образом, если мы ищем false, он находит именно false, а не ноль.

Если мы хотим проверить наличие элемента, и нет необходимости знать его точный индекс, тогда предпочтительным является arr.includes.

Кроме того, очень незначительным отличием includes является то, что он правильно обрабатывает NaN в отличие от indexOf/lastIndexOf:

onst arr = [NaN];
alert( arr.indexOf(NaN) ); // -1 (должен быть 0, но === проверка на равенство не работает для NaN)
alert( arr.includes(NaN) );// true (верно)
Итого
Шпаргалка по методам массива:

Для добавления/удаления элементов:

push (...items) – добавляет элементы в конец,
pop() – извлекает элемент с конца,
shift() – извлекает элемент с начала,
unshift(...items) – добавляет элементы в начало.
splice(pos, deleteCount, ...items) – начиная с индекса pos, удаляет deleteCount элементов и вставляет items.
slice(start, end) – создаёт новый массив, копируя в него элементы с позиции start до end (не включая end).
concat(...items) – возвращает новый массив: копирует все члены текущего массива и добавляет к нему items. Если какой-то из items является массивом, тогда берутся его элементы.
Для поиска среди элементов:

indexOf/lastIndexOf(item, pos) – ищет item, начиная с позиции pos, и возвращает его индекс или -1, если ничего не найдено.
includes(value) – возвращает true, если в массиве имеется элемент value, в противном случае false.
find/filter(func) – фильтрует элементы через функцию и отдаёт первое/все значения, при прохождении которых через функцию возвращается true.
findIndex похож на find, но возвращает индекс вместо значения.
Для перебора элементов:

forEach(func) – вызывает func для каждого элемента. Ничего не возвращает.
Для преобразования массива:

map(func) – создаёт новый массив из результатов вызова func для каждого элемента.
sort(func) – сортирует массив «на месте», а потом возвращает его.
reverse() – «на месте» меняет порядок следования элементов на противоположный и возвращает изменённый массив.
split/join – преобразует строку в массив и обратно.
reduce(func, initial) – вычисляет одно значение на основе всего массива, вызывая func для каждого элемента и передавая промежуточный результат между вызовами.
Дополнительно:

Array.isArray(arr) проверяет, является ли arr массивом.
Обратите внимание, что методы sort, reverse и splice изменяют исходный массив.

Изученных нами методов достаточно в 99% случаев, но существуют и другие.

arr.some(fn)/arr.every(fn) проверяет массив.

Функция fn вызывается для каждого элемента массива аналогично map. Если какие-либо/все результаты вызовов являются true, то метод возвращает true, иначе false.

arr.fill(value, start, end) – заполняет массив повторяющимися value, начиная с индекса start до end.

arr.copyWithin(target, start, end) – копирует свои элементы, начиная со start и заканчивая end, в собственную позицию target (перезаписывает существующие).


*/




// console.log(arr);